"use strict";var _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e};
//! annyang
//! version : 2.6.1
//! author  : Tal Ater @TalAter
//! license : MIT
//! https://www.TalAter.com/annyang/
!function(e,n){"function"==typeof define&&define.amd?define([],function(){return e.annyang=n(e)}):"object"===("undefined"==typeof module?"undefined":_typeof(module))&&module.exports?module.exports=n(e):e.annyang=n(e)}("undefined"!=typeof window?window:void 0,function(r,i){var o,a=r.SpeechRecognition||r.webkitSpeechRecognition||r.mozSpeechRecognition||r.msSpeechRecognition||r.oSpeechRecognition;if(!a)return null;function s(e){for(var n=arguments.length,t=Array(1<n?n-1:0),o=1;o<n;o++)t[o-1]=arguments[o];e.forEach(function(e){e.callback.apply(e.context,t)})}function e(){return d!==i}function u(e,n){-1!==e.indexOf("%c")||n?console.log(e,n||v):console.log(e)}function c(){e()||o.init({},!1)}function f(e,n,t){g.push({command:e,callback:n,originalPhrase:t}),b&&u("Command successfully loaded: %c"+t,v)}function l(e){var n;s(m.result,e);for(var t=0;t<e.length;t++){n=e[t].trim(),b&&u("Speech recognized: %c"+n,v);for(var o=0,r=g.length;o<r;o++){var i=g[o],a=i.command.exec(n);if(a){var c=a.slice(1);return b&&(u("command matched: %c"+i.originalPhrase,v),c.length&&u("with parameters",c)),i.callback.apply(this,c),void s(m.resultMatch,n,i.originalPhrase,e)}}}s(m.resultNoMatch,e)}var d,p,g=[],m={start:[],error:[],end:[],soundstart:[],result:[],resultMatch:[],resultNoMatch:[],errorNetwork:[],errorPermissionBlocked:[],errorPermissionDenied:[]},h=0,y=0,b=!1,v="font-weight: bold; color: #00f;",w=!1,S=!1,k=/\s*\((.*?)\)\s*/g,x=/(\(\?:[^)]+\))\?/g,R=/(\(\?)?:\w+/g,P=/\*\w+/g,C=/[-{}[\]+?.,\\^$|#]/g;return o={addCommands:function(e){var n,t;for(var o in c(),e)if(e.hasOwnProperty(o))if("function"==typeof(n=r[e[o]]||e[o]))f((t=(t=o).replace(C,"\\$&").replace(k,"(?:$1)?").replace(R,function(e,n){return n?e:"([^\\s]+)"}).replace(P,"(.*?)").replace(x,"\\s*$1?\\s*"),new RegExp("^"+t+"$","i")),n,o);else{if(!("object"===(void 0===n?"undefined":_typeof(n))&&n.regexp instanceof RegExp)){b&&u("Can not register command: %c"+o,v);continue}f(new RegExp(n.regexp.source,"i"),n.callback,o)}},start:function(e){c(),w=(e=e||{}).paused!==i&&!!e.paused,p=e.autoRestart===i||!!e.autoRestart,e.continuous!==i&&(d.continuous=!!e.continuous),h=(new Date).getTime();try{d.start()}catch(e){b&&u(e.message)}},abort:function(){p=!1,y=0,e()&&d.abort()},pause:function(){w=!0},resume:function(){o.start()},debug:function(e){b=!!(!(0<arguments.length&&e!==i)||e)},setLanguage:function(e){c(),d.lang=e},removeCommands:function(t){g=t===i?[]:(t=Array.isArray(t)?t:[t],g.filter(function(e){for(var n=0;n<t.length;n++)if(t[n]===e.originalPhrase)return!1;return!0}))},addCallback:function(e,n,t){var o=r[n]||n;"function"==typeof o&&m[e]!==i&&m[e].push({callback:o,context:t||this})},removeCallback:function(e,n){function t(e){return e.callback!==n}for(var o in m)m.hasOwnProperty(o)&&(e!==i&&e!==o||(m[o]=n===i?[]:m[o].filter(t)))},isListening:function(){return S&&!w},getSpeechRecognizer:function(){return d},trigger:function(e){o.isListening()?(Array.isArray(e)||(e=[e]),l(e)):b&&u(S?"Speech heard, but annyang is paused":"Cannot trigger while annyang is aborted")},init:function(e,n){var t=!(1<arguments.length&&n!==i)||n;d&&d.abort&&d.abort(),(d=new a).maxAlternatives=5,d.continuous="http:"===r.location.protocol,d.lang="en-US",d.onstart=function(){S=!0,s(m.start)},d.onsoundstart=function(){s(m.soundstart)},d.onerror=function(e){switch(s(m.error,e),e.error){case"network":s(m.errorNetwork,e);break;case"not-allowed":case"service-not-allowed":p=!1,(new Date).getTime()-h<200?s(m.errorPermissionBlocked,e):s(m.errorPermissionDenied,e)}},d.onend=function(){if(S=!1,s(m.end),p){var e=(new Date).getTime()-h;(y+=1)%10==0&&b&&u("Speech Recognition is repeatedly stopping and starting. See http://is.gd/annyang_restarts for tips."),e<1e3?setTimeout(function(){o.start({paused:w})},1e3-e):o.start({paused:w})}},d.onresult=function(e){if(w)return b&&u("Speech heard, but annyang is paused"),!1;for(var n=e.results[e.resultIndex],t=[],o=0;o<n.length;o++)t[o]=n[o].transcript;l(t)},t&&(g=[]),e.length&&this.addCommands(e)}}});


var map, marker, geofences, watchID, circle, smallCircle, smallerCircle, speed, counter;

function initMap() {

  speed = 10;
  // Initialize the map
  map = new google.maps.Map(document.getElementById('map'), {
    center: { lat: 39.0107, lng: -94.5322 }, // Swope Park
    zoom: 15,
    disableDefaultUI: true
  });

  // Add a marker to the map
  marker = new google.maps.Marker({
    position: { lat: 39.0107, lng: -94.5322 },
    map: map,
    title: 'Current Location'
  });

  // Create an array of geofences
  geofences = [
    {
      center: { lat: 39.0135, lng: -94.5495 },
      radius: 100, // in meters
      strokeColor: 'brown',
      strokeOpacity: 0.3,
      strokeWeight: 4,
      fillColor: 'brown',
      fillOpacity: 0.2,
      alertRadius: 100,
      alertText: 'You found the circle!',
    },
    {
      center: { lat: 39.0145, lng: -94.5485 },
      radius: 100, // in meters
      strokeColor: 'blue',
      strokeOpacity: 0.3,
      strokeWeight: 4,
      fillColor: 'blue',
      fillOpacity: 0.2,
      alertRadius: 100,
      alertText: 'You found the circle!',
    },
  ];

  // Create the geofences
  geofences.forEach(function (geofence) {
    new google.maps.Circle({
      center: geofence.center,
      radius: geofence.radius,
      strokeColor: geofence.strokeColor,
      strokeOpacity: geofence.strokeOpacity,
      strokeWeight: geofence.strokeWeight,
      fillColor: geofence.fillColor,
      fillOpacity: geofence.fillOpacity,
      map: map
    });
  });

  // Initialize the counter
  counter = 0;

  // Watch the user's position
  watchID = navigator.geolocation.watchPosition(function (position) {
    // Update the marker's position
    var latLng = new google.maps.LatLng(position.coords.latitude, position.coords.longitude);
    marker.setPosition(latLng);

    // Check if the user is inside a geofence
    geofences.forEach(function (geofence) {
      var distance = google.maps.geometry.spherical.computeDistanceBetween(latLng, geofence.center);
      if (distance <= geofence.alertRadius) {
        alert(geofence.alertText);
      }
    });


  });

  // Create a small circle that moves towards the user's location every 3 seconds
  setInterval(function () {
    if (!smallCircle) {
      // Get the center of the first geofence
var geofenceCenter = geofences[0].center;

// Create the small circle
smallCircle = new google.maps.Circle({
  center: geofenceCenter,
  radius: 10, // in meters
  strokeColor: 'black',
  strokeOpacity: 0.8,
  strokeWeight: 2,
  fillColor: 'black',
  fillOpacity: 0.35,
  alertRadius: 10,
  alertText: 'You have been killed',
  map: map
});

smallerCircle = new google.maps.Circle({
  center: { lat: 39.0155, lng: -94.5465 },
  radius: 30, // in meters
  strokeColor: 'pink',
  strokeOpacity: 0.8,
  strokeWeight: 2,
  fillColor: 'pink',
  fillOpacity: 0.35,
  alertRadius: 30,
  alertText: 'You are safe',
  map: map
});

} else {
// Move the small circle towards the user's location
var newPosition = google.maps.geometry.spherical.computeOffset(smallCircle.getCenter(), speed, google.maps.geometry.spherical.computeHeading(smallCircle.getCenter(), marker.getPosition()));
smallCircle.setCenter(newPosition);

// Check the distance between the user and the small circle
var distance = google.maps.geometry.spherical.computeDistanceBetween(smallCircle.getCenter(), marker.getPosition());


// Add a listener to detect when the user enters the alert radius
google.maps.event.addListener(smallerCircle, 'radius_changed', function() {
  var distance = google.maps.geometry.spherical.computeDistanceBetween(smallerCircle.getCenter(), marker.getPosition());
  if (distance <= smallerCircle.alertRadius) {
    // If the user is inside the alert radius, add 20 to the speed for 15 seconds
    speed -= 20;
    setTimeout(function() {
      // After 15 seconds, subtract 20 from the speed
      speed += 20;
    }, 15000);
    alert(alertText);
  }
});

if (distance != smallCircle.alertRadius) {

  if (distance < 20) {
    document.getElementById('sentence').innerHTML = 'We are about to die'; setTimeout(function() { window.location.href = 'death.html'; }, 3000);
  }

  else if (distance < 130) {
    document.getElementById('sentence').innerHTML = 'I see enemies all around us, why are we still here'; setTimeout(function() { disappear();}, 5000);
  }

  else if (distance < 220) {
    document.getElementById('sentence').innerHTML = 'I can feel the haunt beginning'; setTimeout(function() { disappear();}, 5000);
  }
}
}
}, 3000);

}






function moveSmallCircle() {
  // Get the user's current location
  navigator.geolocation.getCurrentPosition(function(position) {
    var userLocation = new google.maps.LatLng(position.coords.latitude, position.coords.longitude);

    // Get the current position of the small circle
    var smallCircleCenter = smallCircle.getCenter();

    // Calculate the distance and bearing from the small circle to the user's location
    var distance = google.maps.geometry.spherical.computeDistanceBetween(smallCircleCenter, userLocation);
    var bearing = google.maps.geometry.spherical.computeHeading(smallCircleCenter, userLocation);

    // Calculate the new position of the small circle
    var newSmallCircleCenter = google.maps.geometry.spherical.computeOffset(smallCircleCenter, 5, bearing);

    // Update the position of the small circle
    smallCircle.setCenter(newSmallCircleCenter);

    // Refresh the map to show changes
    map.panTo(newSmallCircleCenter);
  });
}

// Call the moveSmallCircle() function every 3 seconds
setInterval(moveSmallCircle, 3000);
